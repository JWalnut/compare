import progressbar
import networkx as nx
from document import Document
from nltk.corpus import wordnet as wn
import numpy as np

class WordMap:

    @staticmethod
    def generateWordMap(doc, quiet=False):
        i = 0
        map = nx.Graph()
        docSet = set(doc.wordlist)
        if not quiet:
            bar = progressbar.ProgressBar(max_value = len(docSet))
        for word in docSet:
            map.add_edge(word, word)
            synonyms = WordMap.synonymList(word)
            for syn in synonyms:
                if syn in docSet and not map.has_edge(word, syn):
                    map.add_edge(word, syn)
            i += 1
            if not quiet:
                bar.update(i)            
        return map

    @staticmethod
    def synonymList(word):
        list = []
        setList = wn.synsets(word)
        for set in setList:
            for lem in set.lemma_names():
                list.append(str(lem))
        return list

    @staticmethod
    def generateMarkov(theMap):
        adj = np.asarray(nx.adjacency_matrix(theMap).todense())
        N = len(theMap)
        arrayOfOnes = np.ones([N,1])
        rowSums = adj.dot(arrayOfOnes)
        diagonal = np.diag(rowSums.transpose()[0])
        markov = np.linalg.inv(diagonal).dot(adj)
        return markov

    @staticmethod
    def generateDocumentVector(allWords, document):
        totalWords = list(set(allWords.wordlist))
        docWords = list(set(document.wordlist))
        vector = np.zeros([len(totalWords),1])
        for i in range(len(totalWords)):
            if totalWords[i] in docWords:
                vector[i][0] = 1
        return vector

    @staticmethod
    def compareDocs(doc1, doc2, depth=0, quiet=False):
        markovDoc = Document(body=doc1.body+" "+doc2.body)
        markovMap = WordMap.generateWordMap(markovDoc, quiet)
        markov = WordMap.generateMarkov(markovMap)
        doc1vec = WordMap.generateDocumentVector(markovDoc, doc1)
        doc2vec = WordMap.generateDocumentVector(markovDoc, doc2)
        doc1vec /= np.sum(doc1vec)
        doc2vec /= np.sum(doc2vec)
        S1 = markov.dot(doc1vec)
        S2 = markov.dot(doc2vec)
        for i in range(int(depth)):
            S1 = markov.dot(S1)
            s2 = markov.dot(S2)            
        return np.sum(np.absolute(S1.transpose()[0] - S2.transpose()[0]))
